<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple File Share - Static Version</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      background: #2196F3;
      color: white;
      padding: 20px;
      text-align: center;
    }

    .notice {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      padding: 15px;
      margin: 20px;
      border-radius: 4px;
      text-align: center;
    }

    .main-content {
      display: flex;
      min-height: 500px;
    }

    .send-section,
    .receive-section {
      flex: 1;
      padding: 30px;
    }

    .send-section {
      border-right: 2px solid #eee;
    }

    h2 {
      margin-bottom: 20px;
      color: #333;
    }

    .drop-zone {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      margin-bottom: 20px;
      background: #fafafa;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .drop-zone:hover {
      border-color: #2196F3;
      background: #f0f8ff;
    }

    .drop-zone.dragover {
      border-color: #2196F3;
      background: #e3f2fd;
    }

    .file-input {
      display: none;
    }

    .file-info {
      background: #e8f5e8;
      border: 1px solid #4caf50;
      border-radius: 4px;
      padding: 15px;
      margin: 15px 0;
      display: none;
    }

    .file-name {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .file-size {
      color: #666;
      font-size: 14px;
    }

    .share-code-display {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
      margin: 20px 0;
      display: none;
    }

    .share-code {
      font-size: 24px;
      font-weight: bold;
      color: #856404;
      letter-spacing: 2px;
      margin: 10px 0;
      user-select: all;
    }

    .code-input {
      width: 100%;
      padding: 15px;
      font-size: 18px;
      border: 2px solid #ddd;
      border-radius: 4px;
      text-align: center;
      letter-spacing: 2px;
      margin-bottom: 15px;
    }

    .btn {
      background: #2196F3;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      transition: background 0.3s ease;
    }

    .btn:hover {
      background: #1976D2;
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .copy-btn {
      background: #4caf50;
      padding: 10px 20px;
      font-size: 14px;
      width: auto;
      margin-top: 10px;
    }

    .status {
      margin-top: 20px;
      padding: 15px;
      border-radius: 4px;
      text-align: center;
      display: none;
    }

    .status.connected {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      display: block;
    }

    .status.error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
      display: block;
    }

    .instructions {
      margin: 20px;
      padding: 20px;
      background: #e7f3ff;
      border-left: 4px solid #2196F3;
      border-radius: 4px;
    }

    .instructions h3 {
      margin-bottom: 10px;
      color: #1976D2;
    }

    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }

      .send-section {
        border-right: none;
        border-bottom: 2px solid #eee;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>Simple File Share - P2P Version</h1>
      <p>Direct peer-to-peer file sharing using WebRTC</p>
    </div>

    <div class="notice">
      <strong>âš¡ Static Version:</strong> This version works without a server but requires both devices to be on the same
      local network or have direct internet connectivity.
    </div>

    <div class="instructions">
      <h3>ðŸ”§ How it works:</h3>
      <p><strong>1.</strong> Both devices must open this page<br>
        <strong>2.</strong> One person creates a room, the other joins<br>
        <strong>3.</strong> Files are transferred directly between browsers<br>
        <strong>4.</strong> Works best on local networks (same WiFi)
      </p>
    </div>

    <div class="main-content">
      <!-- SEND FILES SECTION -->
      <div class="send-section">
        <h2>ðŸ“¤ SEND FILES</h2>

        <div class="drop-zone" id="dropZone">
          <p>Drag files here or click to select</p>
          <small>Any file type, any size</small>
        </div>

        <input type="file" id="fileInput" class="file-input" multiple>

        <div class="file-info" id="fileInfo">
          <div class="file-name" id="fileName"></div>
          <div class="file-size" id="fileSize"></div>
        </div>

        <button class="btn" id="generateCodeBtn" disabled>Create Room</button>

        <div class="share-code-display" id="shareCodeDisplay">
          <p>Share this room code:</p>
          <div class="share-code" id="shareCode"></div>
          <button class="btn copy-btn" id="copyCodeBtn">Copy Code</button>
          <p><small>Keep this page open while others connect</small></p>
        </div>

        <div class="status" id="sendStatus"></div>
      </div>

      <!-- RECEIVE FILES SECTION -->
      <div class="receive-section">
        <h2>ðŸ“¥ RECEIVE FILES</h2>

        <input type="text" class="code-input" id="codeInput" placeholder="Enter Room Code" maxlength="6">

        <button class="btn" id="connectBtn">Join Room</button>

        <div class="status" id="receiveStatus"></div>

        <div class="download-area" id="downloadArea"></div>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let selectedFiles = [];
    let shareCode = '';
    let peerConnection = null;
    let dataChannel = null;
    let isSender = false;
    let isConnected = false;

    // WebRTC configuration with public STUN servers
    const rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' }
      ]
    };

    // DOM elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileSize = document.getElementById('fileSize');
    const generateCodeBtn = document.getElementById('generateCodeBtn');
    const shareCodeDisplay = document.getElementById('shareCodeDisplay');
    const shareCodeEl = document.getElementById('shareCode');
    const copyCodeBtn = document.getElementById('copyCodeBtn');
    const sendStatus = document.getElementById('sendStatus');

    const codeInput = document.getElementById('codeInput');
    const connectBtn = document.getElementById('connectBtn');
    const receiveStatus = document.getElementById('receiveStatus');
    const downloadArea = document.getElementById('downloadArea');

    // File selection handlers
    dropZone.addEventListener('click', () => fileInput.click());

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      handleFiles(e.dataTransfer.files);
    });

    fileInput.addEventListener('change', (e) => {
      handleFiles(e.target.files);
    });

    // Handle selected files
    function handleFiles(files) {
      if (files.length > 0) {
        selectedFiles = Array.from(files);
        displayFileInfo();
        generateCodeBtn.disabled = false;
      }
    }

    // Display file information
    function displayFileInfo() {
      if (selectedFiles.length === 1) {
        fileName.textContent = selectedFiles[0].name;
        fileSize.textContent = formatFileSize(selectedFiles[0].size);
      } else {
        fileName.textContent = `${selectedFiles.length} files selected`;
        const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
        fileSize.textContent = `Total: ${formatFileSize(totalSize)}`;
      }
      fileInfo.style.display = 'block';
    }

    // Format file size
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Create WebRTC peer connection
    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(rtcConfig);

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log('New ICE candidate:', event.candidate);
          // In a real implementation, you'd send this through a signaling server
          // For now, we'll rely on the default ICE gathering process
        }
      };

      peerConnection.onconnectionstatechange = () => {
        console.log('Connection state:', peerConnection.connectionState);
        if (peerConnection.connectionState === 'connected') {
          isConnected = true;
          showStatus(isSender ? sendStatus : receiveStatus, 'Connected! Ready for file transfer.', 'connected');
        } else if (peerConnection.connectionState === 'failed') {
          showStatus(isSender ? sendStatus : receiveStatus, 'Connection failed. Try refreshing both pages.', 'error');
        }
      };

      return peerConnection;
    }

    // Generate share code and start as sender
    generateCodeBtn.addEventListener('click', async () => {
      shareCode = Math.random().toString(36).substr(2, 6).toUpperCase();
      shareCodeEl.textContent = shareCode;
      shareCodeDisplay.style.display = 'block';
      isSender = true;

      showStatus(sendStatus, 'Room created! Waiting for connections...', 'connected');

      // Create peer connection and data channel
      createPeerConnection();

      // Create data channel for file transfer
      dataChannel = peerConnection.createDataChannel('fileTransfer', {
        ordered: true
      });

      dataChannel.onopen = () => {
        console.log('Data channel opened');
        showStatus(sendStatus, 'Connected! Ready to send files.', 'connected');
        displayAvailableFiles();
      };

      dataChannel.onmessage = (event) => {
        const message = JSON.parse(event.data);
        if (message.type === 'file-request') {
          const fileIndex = message.index;
          if (selectedFiles[fileIndex]) {
            sendFileToReceiver(selectedFiles[fileIndex]);
          }
        }
      };

      // Create and display offer for manual signaling
      try {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        showManualSignaling('offer', offer);
      } catch (error) {
        console.error('Error creating offer:', error);
      }
    });

    // Copy code to clipboard
    copyCodeBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(shareCode);
        copyCodeBtn.textContent = 'Copied!';
        setTimeout(() => {
          copyCodeBtn.textContent = 'Copy Code';
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    });

    // Connect to sender as receiver
    connectBtn.addEventListener('click', async () => {
      const code = codeInput.value.trim().toUpperCase();
      if (code.length !== 6) {
        showStatus(receiveStatus, 'Please enter a valid 6-character code', 'error');
        return;
      }

      isSender = false;
      showStatus(receiveStatus, `Joining room ${code}...`, 'connected');

      // Create peer connection
      createPeerConnection();

      // Handle incoming data channel
      peerConnection.ondatachannel = (event) => {
        const channel = event.channel;
        setupDataChannelReceiver(channel);
      };

      // For static version, show manual connection instructions
      showStatus(receiveStatus, 'Static version: Both users need to be on the same network. Check console for connection details.', 'connected');
    });

    // Setup data channel for receiving files
    function setupDataChannelReceiver(channel) {
      let currentFileData = null;

      channel.onopen = () => {
        console.log('Data channel opened (receiver)');
        showStatus(receiveStatus, 'Connected! Ready to receive files.', 'connected');
      };

      channel.onmessage = async (event) => {
        const message = JSON.parse(event.data);

        if (message.type === 'file-info') {
          currentFileData = {
            name: message.name,
            size: message.size,
            type: message.fileType,
            data: new Uint8Array(message.size),
            received: 0
          };
          console.log('Receiving file:', message.name);
          showStatus(receiveStatus, `Receiving ${message.name}...`, 'connected');

        } else if (message.type === 'file-chunk') {
          if (currentFileData) {
            const chunk = new Uint8Array(message.data);
            currentFileData.data.set(chunk, message.offset);
            currentFileData.received += chunk.length;

            const progress = (currentFileData.received / currentFileData.size) * 100;
            showStatus(receiveStatus, `Downloading ${currentFileData.name}: ${progress.toFixed(1)}%`, 'connected');

            if (currentFileData.received === currentFileData.size) {
              downloadReceivedFile(currentFileData);
              showStatus(receiveStatus, `Download complete: ${currentFileData.name}`, 'connected');
              currentFileData = null;
            }
          }
        } else if (message.type === 'file-list') {
          displayReceivedFiles(message.files);
        }
      };

      dataChannel = channel;
    }

    // Send file through data channel
    async function sendFileToReceiver(file) {
      if (!dataChannel || dataChannel.readyState !== 'open') {
        console.error('Data channel not ready');
        return;
      }

      // Send file info first
      const fileInfo = {
        type: 'file-info',
        name: file.name,
        size: file.size,
        fileType: file.type
      };

      dataChannel.send(JSON.stringify(fileInfo));

      // Send file in chunks
      const chunkSize = 16384; // 16KB chunks
      let offset = 0;

      while (offset < file.size) {
        const chunk = file.slice(offset, offset + chunkSize);
        const arrayBuffer = await readFileChunk(chunk);

        const message = {
          type: 'file-chunk',
          data: Array.from(new Uint8Array(arrayBuffer)),
          offset: offset
        };

        dataChannel.send(JSON.stringify(message));
        offset += chunkSize;

        // Small delay to prevent overwhelming the connection
        await new Promise(resolve => setTimeout(resolve, 10));
      }

      showStatus(sendStatus, `File sent: ${file.name}`, 'connected');
    }

    // Helper to read file chunk
    function readFileChunk(chunk) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.readAsArrayBuffer(chunk);
      });
    }

    // Download received file
    function downloadReceivedFile(fileData) {
      const blob = new Blob([fileData.data], { type: fileData.type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileData.name;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Display available files for sending
    function displayAvailableFiles() {
      if (!isSender || selectedFiles.length === 0) return;

      downloadArea.innerHTML = '';

      selectedFiles.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.style.cssText = `
          background: #f8f9fa;
          border: 1px solid #dee2e6;
          border-radius: 4px;
          padding: 15px;
          margin: 10px 0;
          display: flex;
          justify-content: space-between;
          align-items: center;
        `;
        fileItem.innerHTML = `
          <div>
            <strong>${file.name}</strong><br>
            <small>${formatFileSize(file.size)}</small>
          </div>
          <button class="btn" style="width: auto; padding: 8px 16px; font-size: 14px; background: #28a745;" onclick="sendFile(${index})">Send</button>
        `;
        downloadArea.appendChild(fileItem);
      });

      // Send file list to receiver
      if (dataChannel && dataChannel.readyState === 'open') {
        const fileList = selectedFiles.map(file => ({
          name: file.name,
          size: file.size,
          type: file.type
        }));

        dataChannel.send(JSON.stringify({
          type: 'file-list',
          files: fileList
        }));
      }
    }

    // Display received files for downloading
    function displayReceivedFiles(files) {
      downloadArea.innerHTML = '';

      files.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.style.cssText = `
          background: #f8f9fa;
          border: 1px solid #dee2e6;
          border-radius: 4px;
          padding: 15px;
          margin: 10px 0;
          display: flex;
          justify-content: space-between;
          align-items: center;
        `;
        fileItem.innerHTML = `
          <div>
            <strong>${file.name}</strong><br>
            <small>${formatFileSize(file.size)}</small>
          </div>
          <button class="btn" style="width: auto; padding: 8px 16px; font-size: 14px; background: #28a745;" onclick="requestFile(${index})">Request</button>
        `;
        downloadArea.appendChild(fileItem);
      });
    }

    // Send file (sender side)
    function sendFile(index) {
      if (selectedFiles[index] && dataChannel && dataChannel.readyState === 'open') {
        sendFileToReceiver(selectedFiles[index]);
      }
    }

    // Request file (receiver side)
    function requestFile(index) {
      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify({
          type: 'file-request',
          index: index
        }));
      }
    }

    // Show status message
    function showStatus(element, message, type) {
      element.textContent = message;
      element.className = `status ${type}`;
    }

    // Show manual signaling (for debugging)
    function showManualSignaling(type, data) {
      console.log(`${type.toUpperCase()}:`, JSON.stringify(data, null, 2));
    }

    // Auto-format code input
    codeInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.toUpperCase();
    });
  </script>
</body>

</html>