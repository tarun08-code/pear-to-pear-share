<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple File Share - Supabase</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      background: #2196F3;
      color: white;
      padding: 20px;
      text-align: center;
    }

    .setup-notice {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      color: #856404;
      padding: 20px;
      margin: 20px;
      border-radius: 4px;
    }

    .setup-notice h3 {
      margin-bottom: 10px;
    }

    .setup-notice code {
      background: #f8f9fa;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }

    .main-content {
      display: flex;
      min-height: 500px;
    }

    .send-section,
    .receive-section {
      flex: 1;
      padding: 30px;
    }

    .send-section {
      border-right: 2px solid #eee;
    }

    h2 {
      margin-bottom: 20px;
      color: #333;
    }

    .drop-zone {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      margin-bottom: 20px;
      background: #fafafa;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .drop-zone:hover {
      border-color: #2196F3;
      background: #f0f8ff;
    }

    .drop-zone.dragover {
      border-color: #2196F3;
      background: #e3f2fd;
    }

    .file-input {
      display: none;
    }

    .file-info {
      background: #e8f5e8;
      border: 1px solid #4caf50;
      border-radius: 4px;
      padding: 15px;
      margin: 15px 0;
      display: none;
    }

    .file-name {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .file-size {
      color: #666;
      font-size: 14px;
    }

    .share-code-display {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
      margin: 20px 0;
      display: none;
    }

    .share-code {
      font-size: 24px;
      font-weight: bold;
      color: #856404;
      letter-spacing: 2px;
      margin: 10px 0;
      user-select: all;
    }

    .code-input {
      width: 100%;
      padding: 15px;
      font-size: 18px;
      border: 2px solid #ddd;
      border-radius: 4px;
      text-align: center;
      letter-spacing: 2px;
      margin-bottom: 15px;
    }

    .btn {
      background: #2196F3;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      transition: background 0.3s ease;
    }

    .btn:hover {
      background: #1976D2;
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .copy-btn {
      background: #4caf50;
      padding: 10px 20px;
      font-size: 14px;
      width: auto;
      margin-top: 10px;
    }

    .status {
      margin-top: 20px;
      padding: 15px;
      border-radius: 4px;
      text-align: center;
      display: none;
    }

    .status.connected {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      display: block;
    }

    .status.error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
      display: block;
    }

    .download-area {
      margin-top: 20px;
    }

    .file-item {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 15px;
      margin: 10px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .download-btn {
      background: #28a745;
      padding: 8px 16px;
      font-size: 14px;
      width: auto;
    }

    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }

      .send-section {
        border-right: none;
        border-bottom: 2px solid #eee;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>ðŸš€ Simple File Share - Supabase</h1>
      <p>File sharing with Supabase Realtime signaling</p>
    </div>

    <div class="setup-notice">
      <h3>ðŸ”§ Setup Required:</h3>
      <p>To use this version, you need to:</p>
      <ol>
        <li>Create a free Supabase account at <strong>supabase.com</strong></li>
        <li>Create a new project</li>
        <li>Replace the <code>SUPABASE_URL</code> and <code>SUPABASE_ANON_KEY</code> below</li>
        <li>Create a table called <code>signaling</code> with columns:
          <code>id, room_code, message_type, data, created_at</code></li>
      </ol>
      <p><strong>Benefits:</strong> Real-time messaging, persistent rooms, works perfectly with Vercel!</p>
    </div>

    <div class="main-content">
      <!-- SEND FILES SECTION -->
      <div class="send-section">
        <h2>ðŸ“¤ SEND FILES</h2>

        <div class="drop-zone" id="dropZone">
          <p>Drag files here or click to select</p>
          <small>Any file type, any size</small>
        </div>

        <input type="file" id="fileInput" class="file-input" multiple>

        <div class="file-info" id="fileInfo">
          <div class="file-name" id="fileName"></div>
          <div class="file-size" id="fileSize"></div>
        </div>

        <button class="btn" id="generateCodeBtn" disabled>Create Room</button>

        <div class="share-code-display" id="shareCodeDisplay">
          <p>Share this room code with receivers:</p>
          <div class="share-code" id="shareCode"></div>
          <button class="btn copy-btn" id="copyCodeBtn">Copy Code</button>
          <p><small>Keep this page open while others download</small></p>
        </div>

        <div class="status" id="sendStatus"></div>
        <div class="download-area" id="senderFiles"></div>
      </div>

      <!-- RECEIVE FILES SECTION -->
      <div class="receive-section">
        <h2>ðŸ“¥ RECEIVE FILES</h2>

        <input type="text" class="code-input" id="codeInput" placeholder="Enter Room Code" maxlength="8">

        <button class="btn" id="connectBtn">Connect</button>

        <div class="status" id="receiveStatus"></div>

        <div class="download-area" id="downloadArea"></div>
      </div>
    </div>
  </div>

  <!-- Supabase JS -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    // Supabase configuration
    const SUPABASE_URL = 'https://fmjncwprwibklcafgxps.supabase.co'
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZtam5jd3Byd2lia2xjYWZneHBzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg3ODEyMDksImV4cCI6MjA3NDM1NzIwOX0.O7RLjndFUlu-BAFOKFAhWdI4G-vzPeSc_2uW6rO9rzs'
    
    const { createClient } = supabase;
    const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // File constraints
    const MAX_FILE_SIZE = 450 * 1024 * 1024; // 450MB
    const FILE_EXPIRY_HOURS = 12;    // Global variables
    let selectedFiles = [];
    let shareCode = '';
    let peerConnection = null;
    let dataChannel = null;
    let isSender = false;
    let roomSubscription = null;
    let uploadedFiles = [];

    // WebRTC configuration
    const rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    // DOM elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileSize = document.getElementById('fileSize');
    const generateCodeBtn = document.getElementById('generateCodeBtn');
    const shareCodeDisplay = document.getElementById('shareCodeDisplay');
    const shareCodeEl = document.getElementById('shareCode');
    const copyCodeBtn = document.getElementById('copyCodeBtn');
    const sendStatus = document.getElementById('sendStatus');
    const senderFiles = document.getElementById('senderFiles');

    const codeInput = document.getElementById('codeInput');
    const connectBtn = document.getElementById('connectBtn');
    const receiveStatus = document.getElementById('receiveStatus');
    const downloadArea = document.getElementById('downloadArea');

    // Check if Supabase is configured
    if (!supabase || SUPABASE_URL.includes('your-project')) {
      showStatus(sendStatus, 'âŒ Please configure Supabase credentials in the code', 'error');
      showStatus(receiveStatus, 'âŒ Please configure Supabase credentials in the code', 'error');
    }

    // File selection handlers
    dropZone.addEventListener('click', () => fileInput.click());

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      handleFiles(e.dataTransfer.files);
    });

    fileInput.addEventListener('change', (e) => {
      handleFiles(e.target.files);
    });

    // Handle selected files
    function handleFiles(files) {
      if (files.length > 0) {
        // Validate file sizes
        for (const file of files) {
          if (file.size > MAX_FILE_SIZE) {
            alert(`File "${file.name}" is too large. Maximum file size is ${Math.round(MAX_FILE_SIZE / (1024 * 1024 * 1024))} GB.`);
            return;
          }
        }
        
        selectedFiles = Array.from(files);
        displayFileInfo();
        generateCodeBtn.disabled = false;
      }
    }

    // Display file information
    function displayFileInfo() {
      if (selectedFiles.length === 1) {
        fileName.textContent = selectedFiles[0].name;
        fileSize.textContent = formatFileSize(selectedFiles[0].size);
      } else {
        fileName.textContent = `${selectedFiles.length} files selected`;
        const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
        fileSize.textContent = `Total: ${formatFileSize(totalSize)}`;
      }
      fileInfo.style.display = 'block';
    }

    // Format file size
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Create WebRTC peer connection
    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(rtcConfig);

      peerConnection.onicecandidate = async (event) => {
        if (event.candidate && supabase) {
          await sendSignalingMessage('ice-candidate', {
            candidate: event.candidate
          });
        }
      };

      peerConnection.onconnectionstatechange = () => {
        console.log('Connection state:', peerConnection.connectionState);
        if (peerConnection.connectionState === 'connected') {
          showStatus(isSender ? sendStatus : receiveStatus, 'ðŸŽ‰ Connected! Ready for file transfer.', 'connected');
          if (isSender) {
            displaySenderFiles();
          }
        }
      };

      return peerConnection;
    }

    // Send signaling message via Supabase
    async function sendSignalingMessage(type, data) {
      if (!supabase) return;

      try {
        await supabase
          .from('signaling')
          .insert({
            room_code: shareCode || codeInput.value.trim(),
            message_type: type,
            data: data
          });
      } catch (error) {
        console.error('Error sending signaling message:', error);
      }
    }

    // Subscribe to signaling messages
    function subscribeToRoom(roomCode) {
      if (!supabase) return;

      roomSubscription = supabase
        .channel('signaling')
        .on('postgres_changes', {
          event: 'UPDATE',
          schema: 'public',
          table: 'signaling',
          filter: `room_code=eq.${roomCode}`
        }, handleRoomUpdate)
        .subscribe();
    }

    // Handle room updates (for file changes)
    async function handleRoomUpdate(payload) {
      const { files } = payload.new;

      if (files && files.length > 0 && !isSender) {
        displayAvailableFiles(files);
        showStatus(receiveStatus, 'ðŸ“ New files available!', 'connected');
      }
    }

          await sendSignalingMessage('answer', {
            answer: answer
          });

        } else if (message_type === 'answer' && isSender) {
          await peerConnection.setRemoteDescription(data.answer);

        } else if (message_type === 'ice-candidate') {
          await peerConnection.addIceCandidate(data.candidate);

        } else if (message_type === 'receiver-joined' && isSender) {
          // Create and send offer
          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);

          await sendSignalingMessage('offer', {
            offer: offer
          });
        }
      } catch (error) {
        console.error('Error handling signaling message:', error);
      }
    }

    // Setup data channel
    function setupDataChannel() {
      let currentFileData = null;

      if (isSender) {
        dataChannel = peerConnection.createDataChannel('fileTransfer', {
          ordered: true
        });
      } else {
        peerConnection.ondatachannel = (event) => {
          dataChannel = event.channel;
        };
      }

      const setupChannelEvents = (channel) => {
        channel.onopen = () => {
          console.log('Data channel opened');
          if (!isSender) {
            // Request file list
            channel.send(JSON.stringify({
              type: 'request-file-list'
            }));
          }
        };

        channel.onmessage = async (event) => {
          const message = JSON.parse(event.data);

          if (message.type === 'request-file-list' && isSender) {
            const fileList = selectedFiles.map((file, index) => ({
              index,
              name: file.name,
              size: file.size,
              type: file.type
            }));

            channel.send(JSON.stringify({
              type: 'file-list',
              files: fileList
            }));

          } else if (message.type === 'file-list' && !isSender) {
            displayAvailableFiles(message.files);

          } else if (message.type === 'file-request' && isSender) {
            const fileIndex = message.index;
            if (selectedFiles[fileIndex]) {
              await sendFile(selectedFiles[fileIndex], channel);
            }

          } else if (message.type === 'file-info' && !isSender) {
            currentFileData = {
              name: message.name,
              size: message.size,
              type: message.fileType,
              data: new Uint8Array(message.size),
              received: 0
            };
            showStatus(receiveStatus, `ðŸ“¥ Receiving ${message.name}...`, 'connected');

          } else if (message.type === 'file-chunk' && !isSender) {
            if (currentFileData) {
              const chunk = new Uint8Array(message.data);
              currentFileData.data.set(chunk, message.offset);
              currentFileData.received += chunk.length;

              const progress = (currentFileData.received / currentFileData.size) * 100;
              showStatus(receiveStatus, `ðŸ“¥ Downloading ${currentFileData.name}: ${progress.toFixed(1)}%`, 'connected');

              if (currentFileData.received === currentFileData.size) {
                downloadFile(currentFileData);
                showStatus(receiveStatus, `âœ… Downloaded: ${currentFileData.name}`, 'connected');
                currentFileData = null;
              }
            }
          }
        };
      };

      if (dataChannel) {
        setupChannelEvents(dataChannel);
      } else {
        peerConnection.ondatachannel = (event) => {
          dataChannel = event.channel;
          setupChannelEvents(dataChannel);
        };
      }
    }

    // Generate share code and start as sender
    generateCodeBtn.addEventListener('click', async () => {
      if (!supabase) return;

      shareCode = Math.random().toString(36).substr(2, 8).toUpperCase();
      shareCodeEl.textContent = shareCode;
      shareCodeDisplay.style.display = 'block';
      isSender = true;

      try {
        showStatus(sendStatus, 'ðŸ”„ Creating room and uploading files...', 'connecting');

        // Create room in database
        const { error: insertError } = await supabase
          .from('signaling')
          .insert({
            room_code: shareCode,
            created_at: new Date().toISOString(),
            expires_at: new Date(Date.now() + EXPIRY_TIME).toISOString(),
            files: []
          });

        if (insertError) throw insertError;

        // Upload files to storage
        await uploadFilesToStorage(selectedFiles, shareCode);

        subscribeToRoom(shareCode);
        showStatus(sendStatus, 'âœ… Room created and files uploaded! Share the code with receivers.', 'connected');
        
        // Display uploaded files
        displaySenderFiles();

      } catch (error) {
        console.error('Error creating room:', error);
        showStatus(sendStatus, 'âŒ Failed to create room: ' + error.message, 'error');
      }
    });

    // Connect as receiver
    connectBtn.addEventListener('click', async () => {
      if (!supabase) return;

      const code = codeInput.value.trim().toUpperCase();
      if (!code) {
        showStatus(receiveStatus, 'âŒ Please enter a room code', 'error');
        return;
      }

    // Connect as receiver
    connectBtn.addEventListener('click', async () => {
      if (!supabase) return;

      const code = codeInput.value.trim().toUpperCase();
      if (!code) {
        showStatus(receiveStatus, 'âŒ Please enter a room code', 'error');
        return;
      }

      isSender = false;
      showStatus(receiveStatus, `ðŸ”„ Connecting to ${code}...`, 'connecting');

      try {
        // Check if room exists and get files
        const { data: roomData, error: roomError } = await supabase
          .from('signaling')
          .select('*')
          .eq('room_code', code)
          .single();

        if (roomError || !roomData) {
          throw new Error('Room not found or has expired');
        }

        // Check if room has expired
        if (new Date() > new Date(roomData.expires_at)) {
          throw new Error('Room has expired');
        }

        shareCode = code;
        subscribeToRoom(code);

        if (roomData.files && roomData.files.length > 0) {
          displayAvailableFiles(roomData.files);
          showStatus(receiveStatus, `âœ… Connected to ${code}! Files are ready for download.`, 'connected');
        } else {
          showStatus(receiveStatus, `âœ… Connected to ${code}! Waiting for files...`, 'connected');
        }

      } catch (error) {
        console.error('Error connecting to room:', error);
        showStatus(receiveStatus, 'âŒ Failed to connect: ' + error.message, 'error');
      }
    });

    // Copy code to clipboard
    copyCodeBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(shareCode);
        copyCodeBtn.textContent = 'âœ… Copied!';
        setTimeout(() => {
          copyCodeBtn.textContent = 'Copy Code';
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    });

    // Send file through data channel
    async function sendFile(file, channel) {
      if (channel.readyState !== 'open') return;

      channel.send(JSON.stringify({
        type: 'file-info',
        name: file.name,
        size: file.size,
        fileType: file.type
      }));

      const chunkSize = 16384;
      let offset = 0;

      while (offset < file.size) {
        const chunk = file.slice(offset, offset + chunkSize);
        const arrayBuffer = await readFileChunk(chunk);

        channel.send(JSON.stringify({
          type: 'file-chunk',
          data: Array.from(new Uint8Array(arrayBuffer)),
          offset: offset
        }));

        offset += chunkSize;
        await new Promise(resolve => setTimeout(resolve, 10));
      }

      showStatus(sendStatus, `âœ… Sent: ${file.name}`, 'connected');
    }

    // Helper functions
    function readFileChunk(chunk) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.readAsArrayBuffer(chunk);
      });
    }

    function downloadFile(fileData) {
      const blob = new Blob([fileData.data], { type: fileData.type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileData.name;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Storage-based file sharing functions
    async function uploadFilesToStorage(files, roomCode) {
      try {
        uploadedFiles = [];
        
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          const fileName = `${roomCode}/${Date.now()}_${file.name}`;
          
          showStatus(sendStatus, `ðŸ“¤ Uploading ${file.name}...`, 'connecting');
          
          const { data, error } = await supabase.storage
            .from('shared-files')
            .upload(fileName, file, {
              cacheControl: '3600',
              upsert: false
            });
          
          if (error) throw error;
          
          // Get public URL
          const { data: urlData } = supabase.storage
            .from('shared-files')
            .getPublicUrl(fileName);
          
          const fileInfo = {
            name: file.name,
            size: file.size,
            type: file.type,
            path: fileName,
            url: urlData.publicUrl,
            uploadedAt: new Date().toISOString()
          };
          
          uploadedFiles.push(fileInfo);
          showStatus(sendStatus, `âœ… Uploaded ${file.name}`, 'connected');
        }
        
        // Store file list in signaling table
        await supabase
          .from('signaling')
          .update({ 
            files: uploadedFiles,
            updated_at: new Date().toISOString()
          })
          .eq('room_code', roomCode);
        
        return uploadedFiles;
      } catch (error) {
        console.error('Error uploading files:', error);
        showStatus(sendStatus, 'âŒ Upload failed: ' + error.message, 'error');
        throw error;
      }
    }

    async function downloadFileFromStorage(filePath, fileName) {
      try {
        showStatus(receiveStatus, `ðŸ“¥ Downloading ${fileName}...`, 'connecting');
        
        const { data, error } = await supabase.storage
          .from('shared-files')
          .download(filePath);
        
        if (error) throw error;
        
        // Create download link
        const url = URL.createObjectURL(data);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus(receiveStatus, `âœ… Downloaded ${fileName}`, 'connected');
      } catch (error) {
        console.error('Error downloading file:', error);
        showStatus(receiveStatus, 'âŒ Download failed: ' + error.message, 'error');
      }
    }

    function displaySenderFiles() {
      senderFiles.innerHTML = '';

      selectedFiles.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.innerHTML = `
          <div>
            <strong>${file.name}</strong><br>
            <small>${formatFileSize(file.size)}</small>
          </div>
          <div style="color: #28a745; font-weight: bold;">Ready to send</div>
        `;
        senderFiles.appendChild(fileItem);
      });
    }

    function displayAvailableFiles(files) {
      downloadArea.innerHTML = '';
      showStatus(receiveStatus, 'ðŸ“ Files available for download:', 'connected');

      files.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.innerHTML = `
          <div>
            <strong>${file.name}</strong><br>
            <small>${formatFileSize(file.size)}</small>
            ${file.uploadedAt ? `<br><small style="color: #666;">Uploaded: ${new Date(file.uploadedAt).toLocaleString()}</small>` : ''}
          </div>
          <button class="btn download-btn" onclick="downloadStorageFile('${file.path}', '${file.name}')">Download</button>
        `;
        downloadArea.appendChild(fileItem);
      });
    }

    function downloadStorageFile(filePath, fileName) {
      downloadFileFromStorage(filePath, fileName);
    }

    function requestFile(index) {
      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify({
          type: 'file-request',
          index: index
        }));
      }
    }

    function showStatus(element, message, type) {
      element.textContent = message;
      element.className = `status ${type}`;
    }

    codeInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.toUpperCase();
    });

    window.requestFile = requestFile;
    window.downloadStorageFile = downloadStorageFile;
  </script>
</body>
</html>