<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple File Share - P2P Direct</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      background: #2196F3;
      color: white;
      padding: 20px;
      text-align: center;
    }

    .alert {
      background: #d1ecf1;
      border: 1px solid #bee5eb;
      color: #0c5460;
      padding: 15px;
      margin: 20px;
      border-radius: 4px;
      text-align: center;
    }

    .main-content {
      display: flex;
      min-height: 500px;
    }

    .send-section,
    .receive-section {
      flex: 1;
      padding: 30px;
    }

    .send-section {
      border-right: 2px solid #eee;
    }

    h2 {
      margin-bottom: 20px;
      color: #333;
    }

    .drop-zone {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      margin-bottom: 20px;
      background: #fafafa;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .drop-zone:hover {
      border-color: #2196F3;
      background: #f0f8ff;
    }

    .drop-zone.dragover {
      border-color: #2196F3;
      background: #e3f2fd;
    }

    .file-input {
      display: none;
    }

    .file-info {
      background: #e8f5e8;
      border: 1px solid #4caf50;
      border-radius: 4px;
      padding: 15px;
      margin: 15px 0;
      display: none;
    }

    .file-name {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .file-size {
      color: #666;
      font-size: 14px;
    }

    .share-info {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 4px;
      padding: 20px;
      margin: 20px 0;
      display: none;
    }

    .share-code {
      font-size: 24px;
      font-weight: bold;
      color: #856404;
      letter-spacing: 2px;
      margin: 10px 0;
      user-select: all;
      text-align: center;
    }

    .connection-string {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 10px;
      margin: 10px 0;
      font-family: monospace;
      font-size: 12px;
      word-break: break-all;
      max-height: 100px;
      overflow-y: auto;
    }

    .code-input {
      width: 100%;
      padding: 15px;
      font-size: 18px;
      border: 2px solid #ddd;
      border-radius: 4px;
      text-align: center;
      letter-spacing: 2px;
      margin-bottom: 15px;
    }

    .btn {
      background: #2196F3;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      transition: background 0.3s ease;
    }

    .btn:hover {
      background: #1976D2;
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .btn-small {
      padding: 8px 16px;
      font-size: 14px;
      width: auto;
      margin: 5px;
    }

    .btn-success {
      background: #28a745;
    }

    .btn-success:hover {
      background: #218838;
    }

    .status {
      margin-top: 20px;
      padding: 15px;
      border-radius: 4px;
      text-align: center;
      display: none;
    }

    .status.connected {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
      display: block;
    }

    .status.error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
      display: block;
    }

    .download-area {
      margin-top: 20px;
    }

    .file-item {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 15px;
      margin: 10px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .instructions {
      margin: 20px;
      padding: 20px;
      background: #e7f3ff;
      border-left: 4px solid #2196F3;
      border-radius: 4px;
    }

    .instructions h3 {
      margin-bottom: 10px;
      color: #1976D2;
    }

    .step {
      margin: 10px 0;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
    }

    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }

      .send-section {
        border-right: none;
        border-bottom: 2px solid #eee;
      }

      .connection-string {
        font-size: 10px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>üöÄ Simple File Share - Direct P2P</h1>
      <p>Direct peer-to-peer file sharing using WebRTC</p>
    </div>

    <div class="alert">
      <strong>‚ú® No Server Required!</strong> This version works directly between browsers without needing a signaling server.
    </div>

    <div class="instructions">
      <h3>üìã How to use:</h3>
      <div class="step"><strong>1. SENDER:</strong> Select files ‚Üí Click "Create Connection" ‚Üí Copy the connection data</div>
      <div class="step"><strong>2. RECEIVER:</strong> Paste the connection data ‚Üí Click "Connect" ‚Üí Request files</div>
      <div class="step"><strong>3. SENDER:</strong> Copy the response data ‚Üí Paste it back ‚Üí Connection established!</div>
      <div class="step"><strong>4.</strong> Files transfer directly between browsers - no server involved!</div>
    </div>

    <div class="main-content">
      <!-- SEND FILES SECTION -->
      <div class="send-section">
        <h2>üì§ SEND FILES</h2>

        <div class="drop-zone" id="dropZone">
          <p>üìÅ Drag files here or click to select</p>
          <small>Any file type, any size</small>
        </div>

        <input type="file" id="fileInput" class="file-input" multiple>

        <div class="file-info" id="fileInfo">
          <div class="file-name" id="fileName"></div>
          <div class="file-size" id="fileSize"></div>
        </div>

        <button class="btn" id="createConnectionBtn" disabled>Create Connection</button>

        <div class="share-info" id="shareInfo">
          <h4>üìã Share this connection data with receiver:</h4>
          <div class="connection-string" id="connectionOffer"></div>
          <button class="btn btn-small btn-success" id="copyOfferBtn">Copy Connection Data</button>
          
          <h4 style="margin-top: 20px;">üì• Paste receiver's response here:</h4>
          <textarea class="connection-string" id="answerInput" placeholder="Paste the receiver's response data here..." style="resize: vertical; min-height: 80px; width: 100%;"></textarea>
          <button class="btn btn-small" id="processAnswerBtn">Process Response</button>
        </div>

        <div class="status" id="sendStatus"></div>
        <div class="download-area" id="sendFiles"></div>
      </div>

      <!-- RECEIVE FILES SECTION -->
      <div class="receive-section">
        <h2>üì• RECEIVE FILES</h2>

        <h4>üìã Paste sender's connection data:</h4>
        <textarea class="connection-string" id="offerInput" placeholder="Paste the sender's connection data here..." style="resize: vertical; min-height: 100px; width: 100%;"></textarea>
        
        <button class="btn" id="connectBtn">Connect</button>

        <div class="share-info" id="receiveInfo" style="display: none;">
          <h4>üì§ Copy this response data to sender:</h4>
          <div class="connection-string" id="connectionAnswer"></div>
          <button class="btn btn-small btn-success" id="copyAnswerBtn">Copy Response Data</button>
        </div>

        <div class="status" id="receiveStatus"></div>
        <div class="download-area" id="downloadArea"></div>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let selectedFiles = [];
    let peerConnection = null;
    let dataChannel = null;
    let isSender = false;
    let isConnected = false;

    // WebRTC configuration with multiple STUN servers
    const rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' }
      ]
    };

    // DOM elements
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileSize = document.getElementById('fileSize');
    const createConnectionBtn = document.getElementById('createConnectionBtn');
    const shareInfo = document.getElementById('shareInfo');
    const connectionOffer = document.getElementById('connectionOffer');
    const copyOfferBtn = document.getElementById('copyOfferBtn');
    const answerInput = document.getElementById('answerInput');
    const processAnswerBtn = document.getElementById('processAnswerBtn');
    const sendStatus = document.getElementById('sendStatus');
    const sendFiles = document.getElementById('sendFiles');

    const offerInput = document.getElementById('offerInput');
    const connectBtn = document.getElementById('connectBtn');
    const receiveInfo = document.getElementById('receiveInfo');
    const connectionAnswer = document.getElementById('connectionAnswer');
    const copyAnswerBtn = document.getElementById('copyAnswerBtn');
    const receiveStatus = document.getElementById('receiveStatus');
    const downloadArea = document.getElementById('downloadArea');

    // File selection handlers
    dropZone.addEventListener('click', () => fileInput.click());

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      handleFiles(e.dataTransfer.files);
    });

    fileInput.addEventListener('change', (e) => {
      handleFiles(e.target.files);
    });

    // Handle selected files
    function handleFiles(files) {
      if (files.length > 0) {
        selectedFiles = Array.from(files);
        displayFileInfo();
        createConnectionBtn.disabled = false;
      }
    }

    // Display file information
    function displayFileInfo() {
      if (selectedFiles.length === 1) {
        fileName.textContent = selectedFiles[0].name;
        fileSize.textContent = formatFileSize(selectedFiles[0].size);
      } else {
        fileName.textContent = `${selectedFiles.length} files selected`;
        const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
        fileSize.textContent = `Total: ${formatFileSize(totalSize)}`;
      }
      fileInfo.style.display = 'block';
    }

    // Format file size
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Create WebRTC peer connection
    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(rtcConfig);

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log('ICE candidate:', event.candidate);
        }
      };

      peerConnection.onconnectionstatechange = () => {
        console.log('Connection state:', peerConnection.connectionState);
        const status = isSender ? sendStatus : receiveStatus;
        
        if (peerConnection.connectionState === 'connected') {
          isConnected = true;
          showStatus(status, 'üéâ Connected! Ready for file transfer.', 'connected');
          if (isSender) {
            displaySenderFiles();
          }
        } else if (peerConnection.connectionState === 'failed') {
          showStatus(status, '‚ùå Connection failed. Please try again.', 'error');
        } else if (peerConnection.connectionState === 'connecting') {
          showStatus(status, 'üîÑ Connecting...', 'connected');
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        console.log('ICE connection state:', peerConnection.iceConnectionState);
      };

      return peerConnection;
    }

    // Create connection (sender side)
    createConnectionBtn.addEventListener('click', async () => {
      isSender = true;
      showStatus(sendStatus, 'üîÑ Creating connection...', 'connected');

      try {
        createPeerConnection();

        // Create data channel
        dataChannel = peerConnection.createDataChannel('fileTransfer', {
          ordered: true
        });

        setupDataChannel(dataChannel);

        // Create offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        // Wait for ICE gathering to complete
        await waitForIceGathering();

        // Display the offer
        const offerData = {
          type: 'offer',
          sdp: peerConnection.localDescription
        };

        connectionOffer.textContent = JSON.stringify(offerData, null, 2);
        shareInfo.style.display = 'block';
        showStatus(sendStatus, 'üìã Share the connection data with receiver', 'connected');

      } catch (error) {
        console.error('Error creating connection:', error);
        showStatus(sendStatus, '‚ùå Error creating connection', 'error');
      }
    });

    // Process answer from receiver
    processAnswerBtn.addEventListener('click', async () => {
      try {
        const answerData = JSON.parse(answerInput.value.trim());
        
        if (answerData.type === 'answer') {
          await peerConnection.setRemoteDescription(answerData.sdp);
          showStatus(sendStatus, 'üîÑ Processing response...', 'connected');
        } else {
          throw new Error('Invalid response data');
        }
      } catch (error) {
        console.error('Error processing answer:', error);
        showStatus(sendStatus, '‚ùå Invalid response data. Please check and try again.', 'error');
      }
    });

    // Connect as receiver
    connectBtn.addEventListener('click', async () => {
      isSender = false;
      
      try {
        const offerData = JSON.parse(offerInput.value.trim());
        
        if (offerData.type !== 'offer') {
          throw new Error('Invalid connection data');
        }

        showStatus(receiveStatus, 'üîÑ Connecting...', 'connected');

        createPeerConnection();

        // Handle incoming data channel
        peerConnection.ondatachannel = (event) => {
          dataChannel = event.channel;
          setupDataChannel(dataChannel);
        };

        // Set remote description
        await peerConnection.setRemoteDescription(offerData.sdp);

        // Create answer
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        // Wait for ICE gathering
        await waitForIceGathering();

        // Display the answer
        const answerData = {
          type: 'answer',
          sdp: peerConnection.localDescription
        };

        connectionAnswer.textContent = JSON.stringify(answerData, null, 2);
        receiveInfo.style.display = 'block';
        showStatus(receiveStatus, 'üì§ Copy the response data to sender', 'connected');

      } catch (error) {
        console.error('Error connecting:', error);
        showStatus(receiveStatus, '‚ùå Invalid connection data. Please check and try again.', 'error');
      }
    });

    // Wait for ICE gathering to complete
    function waitForIceGathering() {
      return new Promise((resolve) => {
        if (peerConnection.iceGatheringState === 'complete') {
          resolve();
        } else {
          peerConnection.addEventListener('icegatheringstatechange', () => {
            if (peerConnection.iceGatheringState === 'complete') {
              resolve();
            }
          });
        }
      });
    }

    // Setup data channel
    function setupDataChannel(channel) {
      let currentFileData = null;

      channel.onopen = () => {
        console.log('Data channel opened');
        if (isSender) {
          showStatus(sendStatus, 'üéâ Connected! Ready to send files.', 'connected');
        } else {
          showStatus(receiveStatus, 'üéâ Connected! Requesting file list...', 'connected');
          // Request file list
          channel.send(JSON.stringify({ type: 'request-file-list' }));
        }
      };

      channel.onmessage = async (event) => {
        try {
          const message = JSON.parse(event.data);

          if (message.type === 'request-file-list' && isSender) {
            // Send file list
            const fileList = selectedFiles.map((file, index) => ({
              index,
              name: file.name,
              size: file.size,
              type: file.type
            }));
            channel.send(JSON.stringify({
              type: 'file-list',
              files: fileList
            }));

          } else if (message.type === 'file-list' && !isSender) {
            // Display available files
            displayAvailableFiles(message.files);

          } else if (message.type === 'file-request' && isSender) {
            // Send requested file
            const fileIndex = message.index;
            if (selectedFiles[fileIndex]) {
              await sendFile(selectedFiles[fileIndex], channel);
            }

          } else if (message.type === 'file-info' && !isSender) {
            // Prepare to receive file
            currentFileData = {
              name: message.name,
              size: message.size,
              type: message.fileType,
              data: new Uint8Array(message.size),
              received: 0
            };
            showStatus(receiveStatus, `üì• Receiving ${message.name}...`, 'connected');

          } else if (message.type === 'file-chunk' && !isSender) {
            // Receive file chunk
            if (currentFileData) {
              const chunk = new Uint8Array(message.data);
              currentFileData.data.set(chunk, message.offset);
              currentFileData.received += chunk.length;

              const progress = (currentFileData.received / currentFileData.size) * 100;
              showStatus(receiveStatus, `üì• Downloading ${currentFileData.name}: ${progress.toFixed(1)}%`, 'connected');

              if (currentFileData.received === currentFileData.size) {
                downloadFile(currentFileData);
                showStatus(receiveStatus, `‚úÖ Downloaded: ${currentFileData.name}`, 'connected');
                currentFileData = null;
              }
            }
          }
        } catch (error) {
          console.error('Error processing message:', error);
        }
      };

      channel.onclose = () => {
        console.log('Data channel closed');
        showStatus(isSender ? sendStatus : receiveStatus, 'üì° Connection closed', 'error');
      };

      channel.onerror = (error) => {
        console.error('Data channel error:', error);
        showStatus(isSender ? sendStatus : receiveStatus, '‚ùå Connection error', 'error');
      };
    }

    // Send file through data channel
    async function sendFile(file, channel) {
      if (channel.readyState !== 'open') return;

      // Send file info
      channel.send(JSON.stringify({
        type: 'file-info',
        name: file.name,
        size: file.size,
        fileType: file.type
      }));

      // Send file in chunks
      const chunkSize = 16384; // 16KB chunks
      let offset = 0;

      while (offset < file.size) {
        const chunk = file.slice(offset, offset + chunkSize);
        const arrayBuffer = await readFileChunk(chunk);

        channel.send(JSON.stringify({
          type: 'file-chunk',
          data: Array.from(new Uint8Array(arrayBuffer)),
          offset: offset
        }));

        offset += chunkSize;
        
        // Small delay to prevent overwhelming
        await new Promise(resolve => setTimeout(resolve, 5));
      }

      showStatus(sendStatus, `‚úÖ Sent: ${file.name}`, 'connected');
    }

    // Read file chunk
    function readFileChunk(chunk) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.readAsArrayBuffer(chunk);
      });
    }

    // Download received file
    function downloadFile(fileData) {
      const blob = new Blob([fileData.data], { type: fileData.type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileData.name;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Display sender files
    function displaySenderFiles() {
      sendFiles.innerHTML = '';
      
      selectedFiles.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.innerHTML = `
          <div>
            <strong>${file.name}</strong><br>
            <small>${formatFileSize(file.size)}</small>
          </div>
          <div>Ready to send</div>
        `;
        sendFiles.appendChild(fileItem);
      });
    }

    // Display available files (receiver side)
    function displayAvailableFiles(files) {
      downloadArea.innerHTML = '';
      showStatus(receiveStatus, 'üìÅ Files available for download:', 'connected');
      
      files.forEach((file) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.innerHTML = `
          <div>
            <strong>${file.name}</strong><br>
            <small>${formatFileSize(file.size)}</small>
          </div>
          <button class="btn btn-small btn-success" onclick="requestFile(${file.index})">Download</button>
        `;
        downloadArea.appendChild(fileItem);
      });
    }

    // Request file download
    function requestFile(index) {
      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify({
          type: 'file-request',
          index: index
        }));
      }
    }

    // Copy to clipboard functions
    copyOfferBtn.addEventListener('click', () => copyToClipboard(connectionOffer.textContent, copyOfferBtn));
    copyAnswerBtn.addEventListener('click', () => copyToClipboard(connectionAnswer.textContent, copyAnswerBtn));

    function copyToClipboard(text, button) {
      navigator.clipboard.writeText(text).then(() => {
        const originalText = button.textContent;
        button.textContent = '‚úÖ Copied!';
        setTimeout(() => {
          button.textContent = originalText;
        }, 2000);
      }).catch(() => {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        const originalText = button.textContent;
        button.textContent = '‚úÖ Copied!';
        setTimeout(() => {
          button.textContent = originalText;
        }, 2000);
      });
    }

    // Show status
    function showStatus(element, message, type) {
      element.textContent = message;
      element.className = `status ${type}`;
    }

    // Make requestFile available globally
    window.requestFile = requestFile;
  </script>
</body>

</html>